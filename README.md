1. Hash Function ChoiceFor this project, I utilized MD5 (Message Digest Algorithm 5).Reasoning: While not cryptographically secure by modern standards, MD5 is excellent for consistent hashing because it is fast, deterministic, and produces a 128-bit hash that distributes uniformly across the output space. This uniformity is critical to ensure that keys are spread evenly across the virtual nodes on the ring.Trade-offs: MD5 is slower than non-cryptographic hashes like MurmurHash or FNV-1a, but it is available in Python's standard library (hashlib), ensuring portability without external dependencies.2. VNode AnalysisVirtual Nodes (vnodes) are critical for load balancing.Without VNodes: If a physical node maps to only one point on the ring, the distribution of keys depends entirely on the luck of that single hash value. This often leads to "hot spots" where one node holds 40% of the data while another holds 5%.With VNodes: By mapping each physical node to 100 points on the ring (vnodes), we statistically smooth out the variance. In my simulation, 100 vnodes resulted in a standard deviation significantly lower than using a single node mapping, ensuring no single node was overwhelmed.3. Comparison: Consistent Hashing vs. ModuloModulo Hashing (hash(key) % N): This is the naive approach. If we have 10 nodes and remove 2 (changing N from 10 to 8), the result of % 8 is completely different from % 10 for almost every key. Nearly 100% of keys would have to move.Consistent Hashing: As demonstrated in the simulation, when 20% of the nodes were removed, only roughly 20% of the keys moved. The keys that belonged to the surviving nodes stayed put. This $1/N$ movement property prevents cascading failures in production distributed caches.# Advanced-Implementation-of-a-Consistent-Hashing-Scheme
